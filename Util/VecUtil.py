import pickle
from keras.preprocessing.text import Tokenizer
from APSEC_SO.proj.data.Dataset import preprocess
from APSEC_SO.proj.data.Constants import label_dictionary, output_dictionary
from keras.preprocessing.sequence import pad_sequences
import re
import numpy as np


def train2vec(train, max_word=None, max_len=None):
    """
    convert training data to vec
    save [tokenizer, max_len] into token.pk
    return train_description_vec and train_name_vec
    """
    if max_len is None:
        max_len = [60, 10]
    if max_word is None:
        max_word = [1000, 1000]
    texts = train['description'].apply(preprocess)
    tokenizer = Tokenizer(num_words=max_word[0])
    tokenizer.fit_on_texts(texts=texts)

    # vectorize description
    desc = tokenizer.texts_to_sequences(train['description'].apply(preprocess))
    desc_vec = pad_sequences(maxlen=max_len[0], sequences=desc, padding='post', value=0)

    # vectorize configuration names
    name = tokenizer.texts_to_sequences(train['name'].apply(lambda x: re.split('[-._]', x.strip().lower())))
    name_vec = pad_sequences(maxlen=max_len[1], sequences=name, padding='post', value=0)

    with open("token.pk", 'wb') as token:
        pickle.dump([tokenizer, max_len], token)

    return desc_vec, name_vec


def test2vec(test, path="token.pk"):
    """
    use token.pk generated by func train2vec to convert test data to vec
    return test_description_vec and test_name_vec
    """
    with open(path, 'rb') as token:
        data = pickle.load(token)
        tokenizer, max_len = data[0], data[1]
    # vectorize description
    desc = tokenizer.texts_to_sequences(test['description'].apply(preprocess))
    desc_vec = pad_sequences(maxlen=max_len[0], sequences=desc, padding='post', value=0)
    # vectorize configuration names
    name = tokenizer.texts_to_sequences(test['name'].apply(lambda x: re.split('[-._]', x.strip().lower())))
    name_vec = pad_sequences(maxlen=max_len[1], sequences=name, padding='post', value=0)

    return desc_vec, name_vec


# return one-hot encode for label
def one_hot(num, label_size=7):#changed********************************************************************************************************** label_size=7=> label_size=2
    res = np.zeros(label_size)
    res[num] += 1
    return res


def label2vec(labels):
    label_vec = np.array([one_hot(label_dictionary[label]) for label in labels])
    return label_vec


def vec2label(label_vec):
    labels = [output_dictionary[np.argmax(p)] for p in label_vec]
    return labels
